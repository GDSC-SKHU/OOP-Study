# 03 자바와 객체 지향

### 1️⃣ 객체 지향의 4대 특성
#### 🥬 캡! 상추다
캡 - 캡슐화(Encapsulation) : 정보 은닉(information hiding)
상 - 상속(extends) : 재사용
추 - 추상화(Abstraction) : 모델링
다 - 다형성(Polymorphism) : 사용 편의

### 2️⃣ 클래스 vs 객체
```java
클래스 객체명 = new 클래스();
```
```java
붕어빵틀 붕어빵 = new 붕어빵틀();
```
붕어빵틀과 붕어빵은 클래스와 객체 관계가 아니며 붕어빵틀은 붕어빵을 만드는 팩터리이다.

#### 📌 클래스와 객체를 구분하는 간단한 방법 : **나이**를 물어본다
- 사람은 클래스인가? 객체인가? → 사람의 나이는 몇 살인가? **클래스**
- 김연아은 클래스인가? 객체인가? → 김연아의 나이는 몇 살인가? **객체**
- 뽀로로은 클래스인가? 객체인가? → 뽀로로의 나이는 몇 살인가? **객체**
- 펭귄은 클래스인가? 객체인가? → 펭귄의 나이는 몇 살인가? **클래스**
```
클래스:객체 = 펭귄:뽀로로 = 사람:김연아
```
⭐ **클래스는 분류에 대한 개념이지 실체가 아니다**

### 3️⃣ 추상화
- **추상화 :** 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것
- **객체 :** 세상에 존재하는 유일무이한 사물(속성+기능)
- **클래스 :** 같은 속성과 기능을 가진 객체를 총칭하는 개념(분류)

우리는 객체를 먼저 인식하고 그 객체가 가진 특성에 따라 분류를 통해 클래스를 인식하게 된다.

하지만 사물의 창조주는 "아담"과 "이브"라는 객체를 만들기 전에 클래스라는 개념을 먼저 만들었을 것이다.

우리도 객체 지향에서는 해당 애플리케이션의 창조주가 된다.

애플리케이션 개발자는 클래스를 설계하기 위해 필요한 물체의 공통된 특성을 파악한다.

개발자가 "사람 클래스"를 만든다면 "먹다, 자다, 일하다, 울다, 시력, 몸무게, 나이 등" 여러 공통된 특성을 찾게 된다.

하지만  과연 "사람"의 모든 특성을 나열할 필요가 있을까??

개발자가 필요한 "사람"은 Context(애플리케이션 경계)에 따라 달라질 수 있다.

병원 애플리케이션 → 시력, 몸무게 정보나 접수하다. 등의 기능이 필요하다.

은행 애플리케이션 → 시력, 몸무게 정보는 필요없고 나이, 연봉이나 이체하다. 대출하다. 등의 기능이 필요하다.

결국, IT 관점의 추상화란

**구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것을 말한다.(모델링)**

→ 자바는 이러한 객체 지향의 추상화를 `class 키워드`를 통해 지원하고 있다

#### 📌 객체의 생성과 클래스, 객체 참조 변수
```java
클래스 객체_참조_변수 = new 클래스();
```
<table>
<thead>
  <tr>
    <th>클래스</th>
    <th>객체_참조_변수</th>
    <th>=</th>
    <th>new</th>
    <th>클래스</th>
    <th>()</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>객체_참조_변수의 자료형(Type)</td>
    <td>생성된 객체를 참조할 수 있는 변수</td>
    <td>할당문</td>
    <td>새로운</td>
    <td>만들고자 하는 객체의 분류</td>
    <td>메서드</td>
  </tr>
  <tr>
    <td colspan="3"></td>
    <td colspan="3">클래스의 인스턴스, 즉 객체를 생성하기 위해 객체 생성자를 호출</td>
  </tr>
  <tr>
    <td colspan="6">새로운 객체를 하나 생성해 그 객체의 주소값(포인터)을 객체 참조 변수에 할당</td>
  </tr>
</tbody>
</table>

#### 📌 클래스 멤버 vs 객체 멤버
<table>
<thead>
  <tr>
    <td rowspan="4">클래스 설계</td>
    <td rowspan="2">클래스 멤버</td>
    <td rowspan="2">static</td>
    <td>클래스 멤버 속성</td>
  </tr>
  <tr>
    <td>클래스 멤버 메서드</td>
  </tr>
  <tr>
    <td rowspan="2">객체 멤버</td>
    <td rowspan="2"></td>
    <td>객체 멤버 속성</td>
  </tr>
  <tr>
    <td>객체 멤버 메서드</td>
  </tr>
</thead>
</table>

- 클래스 멤버 = static 멤버 = 정적 멤버
- 객체 멤버 = 인스턴스 멤버

클래스 변수는 해당 클래스의 모든 객체가 같은 값을 가질 때 사용하는 것이 기본이다.

클래스 메서드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메서드이다. ex) Math와 같은 유틸리티성 메서드

#### 📌 3가지 변수 유형
<table>
<thead>
  <tr>
    <th>이름</th>
    <th>다른 이름</th>
    <th>사는 곳(T 메모리)</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>static 변수</td>
    <td>클래스[멤버]속성, 정적 변수, 정적 속성</td>
    <td>스태틱 영역</td>
  </tr>
  <tr>
    <td>인스턴스 변수</td>
    <td>객체[멤버]속성, 객체 변수</td>
    <td>힙 영역</td>
  </tr>
  <tr>
    <td>local 변수</td>
    <td>지역 변수</td>
    <td>스택 영역(스택 프레임 내부)</td>
  </tr>
</tbody>
</table>

### 4️⃣ 상속
상속은 계층적인 개념이 아닌 **재사용과 확장**으로 이해하는 것이 맞다 → 부모-자식 간의 관계 (❌)
ex) 동물은 포유류의 부모가 될 수 없다. 동물을 좀 더 세분화해서 포유류가 나올 수 있다.

**⭐ 상속은 계층도가 아닌 분류도이다**

부모 클래스 - 자식 클래스 (❌)
상위 클래스 - 하위 클래스 (⭕)
슈퍼 클래스 - 서브 클래스 (⭕)

#### 📌 추상화(일반화) vs 구체화(특수화)
![2](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/4ee7b621-df5f-4daa-a469-04c9e45bcc5d)

상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 말하며
하위 클래스 쪽으로 갈수록 구체와, 특수화됐다고 말한다

#### 📌 상속 관계에서 반드시 만족해야 할 문장
**⭐ 하위 클래스는 상위 클래스다** → LSP(리스코프 치환 원칙)
- 영희는 아빠가 될 수 없다. (일반화❌)
- 펭귄은 동물의 역할을 수행할 수 있다. (일반화⭕)

**⭐ 하위 클래스 is a kind of 상위 클래스**
- 펭귄은 한마리의 조류이다 보단 펭귄은 조류의 한 종류이다.

자바 언어에서 inheritance(상속)이라는 키워드는 존재하지 않는다.
대신, **extends(확장)** 가 존재한다.

```
📝 요약
     * 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다
     * 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다
     * 객체 지향의 상속은 is a kind of 관계를 만족해야 한다
```

#### 📌 상속의 강력함
- 상속을 통해 최상위 클래스 Object의 특성을 물려받아 toString() 메서드를 모든 서브클래스에서 사용가능
- 구체화된 객체들을 하나의 일반화된 개념으로 사용할 수 있음

자바는 다중 상속의 다이아몬드 문제로 인해 다중상속을 버리고 **인터페이스**를 도입했다.

#### 📌 상속과 인터페이스
![22](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/12000939-160d-4e96-9f1e-bfc9739e6718)

인터페이스는 `be able to`와 같이 **무엇을 할 수 있는** 형태로 만드는 것이 좋다.

**자바 API 예시**
- Comparable 인터페이스 : 비교할 수 있는
- Runnable 인터페이스 : 실행할 수 있는

인터페이스는 클래스가 '무엇을 할 수 있다'라는 기능을 구현하도록 **강제**하게 된다.

### 5️⃣ 다형성
객체지향에서 다형성이라고 하면 **오버라이딩**과 **오버로딩**이라고 할 수 있다.
하지만 "오버로딩"이 다형성인지에 대해서는 이견이 있다.
- 오버라이딩 : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩 : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

 
```java
Animal pingu = new Penguin();
```
위 코드에서 pingu의 showName() 메서드를 실행하면 Animal 객체에 의해 정의된 메서드가 아니라 Penguin 객체에 의해 재정의된 showName()메서드가 실행됨

**⭐ 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다!**

상위 클래스 참조 변수로 하위 클래스가 오버라이딩한 메서드를 사용할 수 있다.

다형성은 개발자가 프로그램을 작성할 때 **사용편의성**을 준다.

### 6️⃣ 캡슐화
#### 📌 정보은닉하면 생각나는 접근제어자
private, pretected, public

![222](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/5ae4a66b-6ab9-4c35-a204-49d0283b649f)

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 참조 변수를 통해 접근할 것
- 정적 멤버는 클래스명.정적멤버 형식으로만 접근하는 것을 권장

### 📌 참조 변수의 복사
기본 자료형 변수 복사시 에는 `Call by Value`에 의해 복사되어 두 개의 변수가 서로에게 영향을 전혀 주지 않는다.

참조 자료형 변수는 값을 주소, 즉 **포인터**로 판단한다.

결국, 두 자료형 모두 복사시에 자신이 가지고 있는 값을 그대로 복사해서 넘겨준다. 그게 값이냐 주소값이냐의 차이일 뿐이다.
