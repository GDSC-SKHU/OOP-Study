# Chater01. 기계어에서 객체 지향 프로그래밍 언어로

## 1. 기계어
기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현된다.

## 2. 어셈블리어
니모닉과 기계어의 일대일 매칭 코드표를 말한다.
```
     - 니모닉 : 어떤 것을 기억하는데 쉽게 하도록 도움을 주는 것 또는 쉽게 기억되는 성질
``` 
## 3. 어셈블러
CPU마다 기계어가 다르기 때문에 CPU별로 각자의 어셈블리어도 다르다. 
<br>이 어셈블리어를 기계어로 번역해주는 소프트웨어를 어셈블러라고 한다. 

## 4. C언어
하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일 하면, 각 기계에 맞는 기계어 목적 파일이 만들어진다. 어셈블리어 대비 이식성이 좋다. 
```
     - One Source : 하나의 C 소스 파일만 작성
     - Multi Object : 기종마다 하나씩 기계어 목적 파일을 생성
     - Use Anywhere : 모든 컴퓨터에서 실행 가능
``` 

## 5. C++ 언어
C에 객체 지향 개념을 도입한 것이다.

## 6. 자바
진정한 객체 지향인 클래스가 중요한 언어로, 가상 머신이 존재한다. 

## 7. CBD (Component Based Development)
컴포넌트 기반 개발
<br>애플리케이션을 의미 있는 단위로 구분하고 그 단위를 결합하여 소프트웨어 제품을 완성하자는 방법론이자 기법을 말한다.

## 8. SOA (Service Oriented Architecture)
서비스 중심 구조 또는 서비스 지향 구조이다.
<br>개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상을 말한다.<br>

# Chater02. 자바와 절차적 / 구조적 프로그래밍

## 1. 자바 프로그램의 개발과 구동
JVM, 즉 자바 가상 기계의 존재와 역할을 아는 것이 자바 개발 환경을 이해하는 데 필수적이다. 
<br>현실 세계에서 컴퓨터를 구동하기 위해서는 물리적 컴퓨터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요하다.
<br>거기에 더해 소프트웨어를 개발할 수 있는 개발 도구가 필요하다.
<br>프로그램은 개발자가 개발 도구를 이용해 개발하고 운영체제를 통해 물리적 컴퓨터인 하드웨어 상에서 구동된다.
<br>자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다. 
```
     - JDK(Java Development Kit) : 자바 개발 도구
     - JRE(Java Runtime Environment) : 자바 실행 환경
     - JVM(Java Virtual Machine) : 자바 가상 기계
``` 

## 2. 존재하는 절차적/구조적 프로그래밍의 유산
절차적 프로그래밍을 한마디로 표현하자면 goto를 쓰지 말자는 것이다.
<br>goto를 사용하게 되면프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문이다. 
<br>프로그램의 실행 순서를 이리저리 이동할 수 있게 되기 때문에 소스를 이리저리 따라가며 프로그램을 이해해야 한다.
<br>
<br>구조적 프로그래밍이란 함수를 쓰라는 것이다. 함수를 쓰면 좋은 이유는 다음과 깉다.
```
     - 1) 중복 코드를 한 곳에 모아 관리가 가능하다.
     - 2) 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있다.
```
여기에 더해 구조적 프로그램의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것도 있다.
<br>
> 함수와 메소드는 무엇이 다른가?
<br> 전혀 다르지 않다. 굳이 차이점을 뽑자면 함수는 클래스나객체와 아무 관계가 없지만 메소드는 반드시클래스 정의 안에 존재해야 한다.

## 3. main() 메소드 : 메소드 스택 프레임
main() 메소드는 프로그래밍 실행되는 시작점이다. main() 메소드가 실행될 때, 특히 T 메모리의 변화에 대해 살펴보자.
```java
public class Start {
    public static void main(String[] args) {
        System.out.println("Hello OOP");
    }
}
  ```  
```
     1) JRE은 먼저프로그램 안에 main() 메소드가 있는지 확인한다. JRE은 Start 클래스에서 main() 메소드를 발견할 수 있다. 
     2) main()메소드가 확인되면 JRE은 프로그램 실행을 위해 가상 기계인 JVM에 전원을 넣어 부팅한다. 
     3) 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. JVM이 맨 먼저 하는 일은 전처리이다. java.lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다. 
     4) Main 메소드가 실행되기 위해 스택 프레임이 스택 영역에 할당된다. 조금 더 정확히는 여는 중괄호를 만날 때마다 스택 프레임이 하나씩 생긴다.
     5) 그 후 메소드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해야 한다. 즉, 메소드 인자의 변수 공간을 할당하는 것이다.
     6) T 메모리를 구성하고 나면 main() 메소드 안의 첫 명령문을 실행하게 된다.
     7)구문이 실행되면 T 메모리에는 변화가 없다. main() 메소드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다. 그럼 T 메모리도 이제 사라지게 되는 것이다.
```

main() 메소드가 실행되기 전 JVM에서 수행하는 전처리 작업들은 다음과 같다.
<br>- java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다
<br>- Import 된 패키지를 T 메모리의 스태틱 영역에 배치한다
<br>- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

## 4. 변수와 메모리
```java
public class Start2{
    public static void main(String[] args) {
        int i;
        i = 10;
        
        double d = 20.0;
    }
}
  ``` 
<br>
1) int i
<br>메모리에 4바이트 크기의 정수 저장 공간을 마련하라는 것이다. 이 공간은 main() 소드 스택 프레임 안에 밑에서부터 차곡차곡 변수 공간을 마련한다.
<br>변수 i를 선언만 하고 초기화하지 않은 상태에서 i 변수를 사용하는 코드를 만나면 자바 컴파일러는 “The local variable I may not have been initialized” 경고를 보낸다.
<br>지역 변수 i가 초기화되지 않았다는 메세지이다.
<br><br>
2) double d = 20.0
<br>하나의 명령문이 아닌 두 개의 명령문이다. 변수를 선언하는 명령문과 변수에 값을 할당하는 명령문 두개가 한 줄에 있는 것이다. 
<br>닫는 중괄호로 main() 메소드 스택 프레임이 스택 영역에서 사라지며 프로그램이 종료된다.

## 5. 블록 구문과 메모리 : 블록 스택 
```java
public class Start3 {
    public static void main(String[] args) {
        int i = 10;
        int k = 20;

        if(i == 10) {
            int m = k + 5;
            k = m;
        }	else {
            int p = k + 10;
            k = p;
        }

        //k = m + p;
    }
}
```
if는 조건에 따라 분기를 일으킬 것이다.
<br>여는 중괄호를 만나면 스택 프레임이 시작되는데, 여기서 만들어지는 스택 프레임은 메소드 스택 프레임이 아니라 if문, 그것도 참인 블록의 스택 프레임이다.
<br>main() 메소드의 스택 프레임 안에 if 문의 블록 스택 프레임이 중첩되어 생성된다.
<br>m = k+5 구문은 if 스택 프레임 안의 변수 m에 값을 할당한다. 이때 if 스택 프레임 밖에 있으면서 main() 메소드 스택 프레임 안에 있는 k 변수를 참여시킨다.
<br>if 블록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라진다. 
<br>이때 if 블록 스택 프레임 안에 상주하던 변수의 저장 공간도 사라진다.
<br>닫는 기호인 중괄호를 사용하면 T 메모리 소멸, JVM 가동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납하게 된다.

## 6. 지역 변수와 메모리
변수는 스태틱 영역, 스택 영역, 힙 영역 세 군데의 메모리에 존재한다.
<br>하지만 세 군데 각각에 있는 변수는 각기 다른 목적을 가진다. 또한 각각의 이름도 지역 변수, 클래스 멤버 변수, 객체 멤버 변수로 다르다.<br>
<br><b>지역 변수</b> : 스택 영역에 존재한다. 그것도 스택 프레임 안에서 존재한다. 따라서 스택 프레임이 사라지면 함께 사라진다.
<br><b>클래스 멤버 변수</b> : 스태틱 영역에 존재한다. 스태틱 영역에 한 번 자리잡으면 JVM이 종료될 때까지 고정된(static) 상태로 유지된다.
<br><b>객체 멤버 변수</b> : 힙에서 존재한다. 객체 멤버 변수들은 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 종료된다.
<br>
<br>외부 스택 프래임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.
<br>그래서 스택 메모리 내의 스택 프레임 안의 변수를 지역 변수라고 한다. 스택 프레임에서만 사용할 수 있고 외부에서는 사용할 수 없기 때문이다. 
<br>또한 그 지역이 사라지면 지역 변수도 메모리에서 함께 사라진다.

## 7. 메소드 호출과 메모리 : 메소드 스택 프레임 2
```java
public class Start4 {
    public static void main(String[] args) {
        int k = 5;
        int m;

        m = square(k);
    }

    private static int square(int k) {
        int result;

        k = 25;

        result = k;

        return result;
    }
}
```
square라는 메소드 호출이 일어나면, 무조건 호출되는 메소드의 스택 프레임이 T 메모리 스택 영역에 새로 생성된다. 
<br>main()메소드가 가진 변수 k와 square() 메소드가 가진 변수 k가 이름만 같지 실제로는 서로 별도의 변수 공간이다.
<br>이것을 Call By Value(값에 의한 호출)이라고 한다. 메소드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달하는 것이다.
<br>그래서 square() 메소드 안의 k 변수는 main()메소드 안의 k 변수에 영향을 끼치지 않는다.
<br>square() 메소드의 끝을 알리는 닫는 중괄호를 만나면 square() 메소드 스택 프레임은 스택에서 사라진다. 
<br>하지만 반환값이 있으니 그 값을 돌려주면서 스택에서 사라진다.

> main() 메소드의 어디에선가 square() 메소드 내의 지역 변수 result에 직접 접근 가능한가?
> 또는 square() 메소드의 지역 변수 m에 직접 접근 가능한가?
답은 접근할 수 없다 이다.
<br>입력값들과 반환값에 의해서만 메소드 사이에서 값이 전달될 뿐 서로 내부의 지역변수를 볼 수 없다는 것을 메소드를 블랙박스화 한다고 한다.
<br>square() 메소드 내의 실행 명령문에서는 T 메모리 안에 존재하는 main 메소드의 지역 변수를 참조할 수 없다. 이유는 다음과 같다.
```
     1) 메소드는 고유 공간인데, 서로 침범하면 문제가 발생할 수 있다.
     2) 포인터 문제때문이다. 
     3) 자바는 포인터를 사용할 수 없으므로 결국 언어 스펙상으로도 서로의 변수를 참조하는 것은 불가능하다.
     4)구문이 실행되면 T 메모리에는 변화가 없다. main() 메소드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다. 그럼 T 메모리도 이제 사라지게 되는 것이다.
```
메소드 사이에 값을 전달하거나 반환하는 방법은 메소드의 인자와 반환값으로만 가능하다.
<br>물론 전역 변수(공유 변수)도 있지만 가급적 사용하지 않는 것이 좋다.

## 8. 전역 변수와 메모리
위에서 말했던 것처럼 전역 변수를 사용하는 방법이 있다. 
<br>전역 변수는 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수라고 하며, 여러 메소드들이 공유해서 사용한다고 해서 공유 변수라고도 한다.
<br>전역 변수는 프로그램 규모에 따라 코드가 커지면서 여러 메소드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장되어 있는 값을 파악하기 쉽지 않다.
<br>그렇기 때문에 전역 변수는 피할 수 있다면 피해야 한다. 다만 읽기 전용으로 값을 공유하는 경우에는 사용해도 된다.

## 9. 멀티 스레드 / 멀티 프로세스의 이해
<b>멀티 스레드</b>
```
     T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.
     하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다.
     T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용한다.
     따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.
```


<b>멀티 프로세스</b>
```
     다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.
     각 프로세스마다 각자의 T 메모리가 있고 고유한 공간이므로 서로 참조할 수 없다.
     하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량이 그만큼 크다.
```

```java
public class Start6 extends Thread{
    static int share;
    public static void main(String[] args) {
        Start6 a1 = new Start6();
        Start6 a2 = new Start6();

        a1.start(); // 스레드 실행 => run() 실행
        a2.start(); // 스레드 실행 => run() 실행
    }

    public void run(){
        for(int count = 0; count < 10; count++){
            System.out.println(share++);

            try {
                sleep(1000);
            }
            catch (InterruptedException e){

            }
        }
    }
}
```
<br>
첫 번째 스레드가 share 변수를 1 증가시키기 전에, 두 번째 스레드가 share 변수를 변경하여 첫 번째 스레드의 작업 결과를 덮어쓰는 경우가 발생할 수 있다.
<br><b>스레드 안전성 문제</b> 참고 블로그 : https://developer-ellen.tistory.com/205

## 10. 정리
```
     스태틱 : 클래스의 놀이터
     스택 : 메소드의 놀이터
     힙 ; 객체의 놀이터
```
<br>

# Chater03. 자바와 객체 지향

## 1. 객체 지향은 인간 지향이다.
0과 1로 대변되는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실 세계를 인지하는 방식으로 프로그램을 만들자는 것이다. 
<br>그래서 객체 지향은 직관적이다. 객체 지향을 이해하기 위해 먼저 큰 그림을 생각해보자.
```
     세상에 존재하는 모든 것은 사물, 즉 객체이다.
     각각의 사물은 고유하다.
     사물은 속성을 갖는다.
     사물은 행위를 한다.
```
그리고 사물을 하나하나 이해하기 보다는 사물을 분류(class)해서 이해하는 것이 인간의 인지법이다.
```
     직립 보행을 하며 말을 하는 존재를 사람이라고 분류한다.
     연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류한다.
     밤하늘에 반짝이는 사물들을 별이라고 분류한다.
```
사람이라는 분류 안의 객체(object)들은 나이, 몸무게, 키 등의 속성(property)과 먹다, 자다, 울다 등의 행위(method)를 가지고 있다.
<br>객체 지향 이전에는 속성과 메소드를 객체라는 단위로 묶지 않고 속성(필드) 따로, 메소드(함수) 따로 분리된 형태로 프로그램을 작성했었는데,
<br>객체 지향에서는 우리가 주변에서 실제 사물을 인지 및 사고하는 방식대로 객체 단위의 프로그래밍이 가능하다.
<br>객체 지향은 인간의 인지 및 사고 방식까지 프로그래믕에 접목하는 인간(개발자) 지향을 실천하고 있는 것이기에 직관적이다.

## 2. 객체 지향의 4대 특성
```
     캡슐화 : 정보 은닉
     상속 : 재사용
     추상화 : 모델링
     다형성 : 사용 편의
```

## 3. 추상화 : 모델링
추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것을 말한다. 즉, 모델링이다.
<br>객체 지향의 4대 특성은 클래스, 또는 객체를 통해 구현된다.
<br>객체란 세상에 존재하는 유일무이한 사물을 뜻한다. 이에 대비되는 클래스는 분류 / 집합 / 같은 속성과 기능을 가진 객체를 총칭하는 개념이다.
<br>세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류하니 객체를 통칭할 수 있는 집합적 개념, 즉 클래스가 나오게 된다.
<br>새로운 사람이 태어난 것을 자바로 표현하면 다음과 같다.
```java
사람 홍길동 = new 사람();
```
또 새로운 사람이 태어났는데 이번에는 이름을 허지영이라고 해보자.
```java
사람 허지영 = new 사람();
```
사람이라는 클래스를 이용해 유일무이하고 새로운 하나의 사람(객체)을 만들어 허지영(객체 참조 변수)이라는 이름을 지어준 것이다.
<br>클래스는 class, 객체는 Object이다. 클래스를 이용해 object를 만들었다는 것을 강조할 때는 인스턴스(instance)라는 표현을 쓴다.
```
     OOP의 추상화는 모델링이다.
     클래스 : 객체 = 펭귄 : 뽀로
     클래스 설계에서 추상화가 사용된다.
     클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다. 
     객체 지향에서 추상화의 결과는 클래스다.
```
사실 추상화의 개념을 넓게 본다면 아래 내용도 포함된다.
```
     상속을 통한 추상화, 구체화
     인터페이스를 통한 추상화
     다형성을 통한 추상화
```
자바는 객체 지향의 추상화를 class 키워드를 통해 지원한다.
<br>클래스와 객체 관계를 자바에서는 다음과 같이 나타낸다.
```java
클래스 객체_참초_변수 = new 클래스();
```

## 4. 추상화와 T 메모리
java.lang 패키지와 모든 클래스들이 T 메모리의 스태틱 영역에 배치된다. 
```java
public class Mouse{
    public String name;
    public int age;
    public int countOfTail;

    public void sing(){
        System.out.println(name + "찍찍~~~");
    }
}
```
Mouse클래스를 생성해준다. 이 클래스를 통해 객체를 생성한다.
```java
public class MouseDriver{
    public static void main(String[] args) {
        Mouse mickey = new Mouse();
        mickey.name = "미키";
        mickey.age = 85;
        mickey.countOfTail = 1;

        mickey.sing();

        mickey = null;
        
        Mouse jerry = new Mouse();

        jerry.name = "제리";
        jerry.age = 73;
        jerry.countOfTail = 1;

        jerry.sing();
    }
}
```
T메모리를 살펴보면 Mouse에서 name, age, countOfTail의 변수 저장 공간이 보이지 않는다. 그저 이름만 존재한다.
<br>이 세 개의 속성은 Mouse 클래스에 속한 속성이 아닌 Mouse 객체에 속한 속상이기 때문이다.
<br>객체가 생성돼야만 속성의 값을 저장하기 위한 메모리 공간이 스태틱 영역이 아닌 힙 영역에 할당된다.
<br><b>Mouse mickey</b> : Mouse 객체에 대한 참조 변수 mickey 만든다.
<br><b>new Mouse()</b> : Mouse 클래스의 인스턴스를 하나 만들어 힙에 배치한다.
<br><b>대입문</b> : Mouse 객체에 대한 주소(포인터)를 참조 변수 mickey에 할당한다.
<br>
<br><b>스태틱</b> : 고정된 이라는 뜻을 가지고 있다.
<br>스태틱 영역에 올라간 정보는 main() 메소드가 시작되기 전에 올라가서 main() 메소드가 종료된 후에 내려올 정도로 스태틱 영역에 단단히 고정되어 있기 때문에 스태틱 영역이라고 한다.
<br><b>힙</b> : 대용량 자료를 저장할 수 있도록 메모리를 사용하는 방식이다.

## 5. 클래스 멤버 vs. 객체 멤버 = static 멤버 vs. 인스턴스 멤버
같은 유형(클래스)의 모든 객체가 같은 값을 가지고 있다면 그 값을 클래스에 저장하는 것도 방법이다.
```java
public class Mouse{
    public String name;
    public int age;
    public static int countOfTail = 1;

    public void sing(){
        System.out.println(name + "찍찍~~~");
    }
}
```
아제 countOfTail속성은 T 메모리의 스태틱 영역에 단 하나의 저장 공간을 갖게 된다. 
```java
public class MouseDriver{
    public static void main(String[] args) {
        // 클래스명.countOfTail
        Mouse.countOfTail = 1;

        Mouse mickey = new Mouse();
        Mouse jerry = new Mouse();
        Mouse mightyMouse = new Mouse();
        
        // 객체명.countOfTail
        System.out.println(mickey.countOfTail);
        System.out.println(jerry.countOfTail);
        System.out.println(mightyMouse.countOfTail);
        
        // 클래스명.countOfTail
        System.out.println(Mouse.countOfTail);
    }
}
```
이렇게 static 키워드가 붙은 속성을 클래스 멤버 속성이라고 한다.
<br>static이 안 붙은 속성은 객체 멤버 속성이라고 한다.
<br>속성 뿐만 아니라 메소드도 static 키워드를 붙였느냐 안 붙였느냐에 따라 클래스 멤버 메소드, 객체 멤버 메소드로 분류한다.
<br>main() 메소드를 보면 static 키워드가 항상 붙어있는 것을 볼 수 있는데, 이 메소드가 바로 클래스 멤버 메소드이기 때문이다.
<br>클래스 멤버들은 static 키워드와 함께 사용되고 또 T 메모리의 static 영역에 상주하게 되므로 static(정적) 멤버라고도 한다.
<br>객체 멤버들은 객체가 클래스의 인스턴스이므로 인스턴스 멤버라고도 한다.
```java
클래스 멤버 = static 멤버 = 정적 멤버
객체 멤버 = 인스턴스 멤버
```
정적 속성은 해당 클래스의 모든 객체가 같은 값을 가질 때 사용하는 것이 기본이다.
<br>정적 메소드는 객체들의 존재여부에 관계없이 쓸 수 잇는 메소드다.
<br>정적 멤버들은 객체가 아닌 클래스에 속해 있으며, 클래스는 JVM 구동 시 T 메모리의 스태틱 영역에 바로 배치되기 때문에 객체의 존재 여부에 관계 없이 쓸 수 있다.
<br>정적 속성인 경우 T 메모리의 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보되는 것을 보여준다.
<br>이에 반해 객체 속성은 속성명만 있지 실제 메모리 공간을 확보하지 않는다.
<br>객체 속성은 힙 영역에 객체가 생성되면 바로 그때 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당된다.

> 지역 변수는 별도로 초기화해야 하는데 멤버 변수(속성)은 왜 자동으로 초기화 해줄까?

지역 변수는 한 지역에서만 쓰는 변수이지만 멤버 변수는 공유 변수의 성격을 가지고 있기 때문이다.
<br>객체 변수는 하나의 객체 안에서 다수의 객체 메소드가 공유하는 변수이고, 클래스 변수는 전역 변수로서 프로그램 어디서든 접근 가능한 공유 변수다.

> 이러한 공유 변수의 초기화는 누가 해야 할까?

객체 멤버인 경우는 생성자를 통해, 정적 멤버는 정적 실행 영역을 통해 초기화하는 경우가 있긴 하지만 공유 변수를 딱히 누가 초기화해야 한다고 규정할 수는 없다.
<br>그래서 공유 변수는 별도로 초기화를 해주지 않아도 기본값으로 초기화되는 것이다.
```java
static 변수 = 클래스 속성, 정적 변수, 정적 속성 = 스태틱 영역에 저장
인스턴스 변수 = 객체 속성, 객체 변수 = 힙 영역에 저장
local 변수 = 지역 변수 = 스택 영역에 저장
```

## 6. 상속 : 재사용 + 확장
상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미이다.
<br>부모 클래스 - 자식 클래스보다 상위 클래스 - 하위 클래스 또는 슈퍼 클래스 - 서브 클래스 라는 말이 옳은 표현이다.
<br>상위 클래스로 갈수록 추상화, 일반화 됐다고 하며 하위 클래스로 갈수록 구체화, 특수화 됐다고 말한다.
<br>하위 클래스는 상위 클래스인 점을 반드시 만족해야 한다.

> 상속의 강력함
> 
<br>클래스 상속 구조에서 최상위 클래스는 Object이다. 그래서 모든 클래스는 결국 Object의 특성을 물려받는다.
<br>그래서 어떤 클래스의 인스턴스이든 상관없이 개발자는 toString() 메소드를 사용할 수 있다는 강점이 있다.

> 상속은 is a 관계를 만족해야 하는가?

is a 관계는 객체(클래스와 인스턴스)와 클래스의 관계로 오해될 소지가 많다.
<br>때문에 is a kind of 관계를 사용하는 것이 옳다. 
<br>하위 클래스 is a kind of 상위 클래스인 점을 사용하는 것이 옳다.

> 다중 상속과 자바

자바가 다중 상속을 지원하지 않는 이유는 득실 관계에서 실이 더 많았기 때문에 과감히 포기했다. 
<br>인터페이스를 도입해 다중 상속의 득은 취하고 실은 과감히 버렸다.

> 상속과 인터페이스

다중 상속을 포기하고 대신 인터페이스를 도입한 자바에서 인터페이스는 어떤 관계를 나타낼까?
<br>인터페이스는 be able to, 즉 "무엇을 할 수 있는" 이라는 표현 형태로 만드는 것이 좋다.
```java
Serializable : 직렬화할 수 있는
Cloneable 복제할 수 있는
Comparable : 비교할 수 있는
Runnable : 실행할 수 있는
```

> 상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋을까? 적을수록 좋을까?
> 인터페이스는 구현을 강제할 메소드가 많을수록 좋을까? 적을수록 좋을까?

상위클래스는 물료줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메소드의 개수가 적을수록 좋다.
<br>그 이유는 LSP(리스코프 치환 법칙)에 다른 이유라고 할 수 있다.
<br><b>리스코프 치환 법칙</b> 참고 블로그 : https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-LSP

## 7. 다형성 : 사용편의성
상위 클래스와 하위 클래스 사이에서도 다형성을 이야기할 수 있고, 인터페이스와 그것의 구현 클래스 사이에서도 다형성을 이야기할 수 있지만, 가장 기본은 오버라이딩과 오버로딩이다.

```java
오버라이딩 : 같은 메소드 이름, 같은 인자 목록으로 상위 클래스의 메소드를 재정의
오버로딩 : 같은 메소드 이름, 다른 인자 목록으로 다수의 메소드를 중복 정의
```

> 다형성과 T 메모리

상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메소드기 호출된다.

## 8. 캡슐화 : 정보 은닉
> 객체 멤버의 접근 제어자

자신의 멤버가 아닌 다른 객체의 멤버에 접근하는 경우에는 다른 객체를 생성한 후 접근해야 한다.
```java
public : 모두가 접근 가능
protected - 상속 : 패키지내의 클래스에서 접근 가능
default : 같은 패키지 내의 클래스에서 접근 가능
private : 본인만 접근 가능
```
특정 객체 멤버에 대한 접근인지, 정적 멤버에 대한 접근인지에 따라 생각해야 한다.
<br>정적 멤버인 경우 클래스명.정적멤버 형식으로 접근해야 하는데, 일관된 형식으로 접근하기 위해서이다.
<br>객체를 생성한 경우에는 객체참조변수명.정적멤버 형태로도 접근할 수도 있다. 

> 참조 변수의 복사

Call By Value 와 Call By Reference는 본질적으로 차이가 없다.
<br>다만 차이라면 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하는 반면, 객체 참조 변수는 저장하고 있는 값을 주소로 해석한다는 차이가 있다.
<br>기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고, 참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는 것이 더 쉽다.
<br>차이점 블로그 : https://velog.io/@ahnick/Java-Call-by-Value-Call-by-Reference

```
기본 자료형 변수는 값을 값 자체로 판단한다.
참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 
즉 가지고 있는 값을 그대로 복사해서 넘겨준다.
```
