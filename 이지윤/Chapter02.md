## Chapter 2. 자바와 절차적 / 구조적 프로그래밍

---

###  📍 자바 프로그램의 개발과 구동

- JDK (Java Development Kit) : 자바 개발 도구
- JRE (Java Runtime Environment) : 자바 실행 환경
- JVM (Java Virtual Machine) : 자바 가상 기계


###  📍 객체 지향 메모리

* 프로그램 메모리 구조 
  * 코드 실행 영역과 데이터 저장 영역 **두 영역**으로 나뉨.


* 객체 지향 프로그램 메모리 구조 (**T 메모리 구조**) 
  * 데이터 저장 영역이 세 가지 영역으로 나뉨.
    * **Static** - 클래스들의 놀이터
    * **Stack** - 메서드들의 놀이터
    * **Heap** - 객체들의 놀이터


* 구조적 프로그래밍 (함수 사용) 
  * 중복 코드를 한 곳에 모아서 관리 가능 
  * 논리를 함수 단위로 분리해서 이해하기 쉬운 코드 작성 가능   
  * 전역 변수보다 지역 변수를 사용하는 것은 권장

---
### ⭐️ T 메모리 구조의 흐름

```java
public class Start {
	public static void main(String[] args) {
		System.out.println("Hello OOP!!!");
	}
}
```

1. JRE - **main(**) 있는지 여부 판단 


2. JVM 부팅


3. JVM **전처리 과정** 실행
   1. **java.lang 패키지**를 T 메모리 스태틱 영역에 배치
   2. **import 패키지**를 T 메모리 스태틱 영역에 배치 
   3. 프로그램 상의 **모든 클래스**를 T 메모리 스태틱 영역에 배치


4. **stack frame 할당** ( 여는 중괄호를 만날 때마다 생성 )


5. stack frame 아래에 메서드 인자를 저장할 **변수 공간 확보** 


6. Stack Frame이 닫는 괄호를 만나면 소멸


7. JVM 종료 -> JRE 메모리에서 사라짐 -> T 메모리도 빠이빠이

### 변수와 메모리

```java
public class Start2 {
	public static void main(String[] args) {
		int i;
		i = 10;

		double d = 20.0;
	}
}
```
1. 위의 전처리 실행 과정은 동일


2. int i 초기화 (1 stack frame)-> 전에 사용했던 값을 가지고 있어 초기화 시켜줘야함.


3. i 스택 프레임에 10의 값이 들어감.


4. double d 는 초기화와 동시에 스택프레임에 값이 들어감.

### 블록 구문과 메모리

```java
public class Start3 {
	public static void main(String[] args) {
		int i = 10;
		int k = 20;

		if(i == 10) {
			int m = k + 5;
			k = m;
		} else {
			int p = k + 10;
			k = p;
		}

		//k = m + p;
	}
}
```

<img src="https://user-images.githubusercontent.com/84395062/235965149-5da19319-cc59-4498-bc81-e42156fa6bca.jpg" width="300px" />

### 지역 변수와 메모리 

- 변수는 static, stack, heap 영역 **모든 곳에 다른 목적**을 가지고 존재한다.
- 지역 변수 : 스택 메모리 내의 스텍 프레임 안의 변수
  - 지역(스택 프레임) 안에서만 사용이 가능함.
  - 지역이 사라지면 지역 변수도 메모리에서 사라짐.

> 외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.


### 메서드 호출과 메모리

```java
public class Start4 {
    public static void main(String[] args) {
        int k = 5; // 1
        int m; // 1

        m = square(k); // 5
    }

    private static int square(int k) {
        int result; // 2

        k = 25; 

        result = k; // 3

        return result; // 4
    }
}
```

1. main() 스택 프레임에 k,m 변수를 담고 있음. </br>
   🚨 static에 square가 저장됨.

2. square() 스택 프레임이 생성되고 result, k , 반환값이라는 변수를 가지고 있음.


3. k가 가지고 있는 25를 result 값에 저장해줌. </br>
   🚨 이때 k는 main에서의 k와는 다름.


4. result의 값이 반환값이 됨. 


5. square(k) 메소드를 호출해서 m을 반환함. 

> Call By Value : 메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만은 복제해서 전달하는 방식

### 전역 변수와 메모리 ( 웬만하면 피해라. )

- 스택 프레임에 종속적인 지역 변수
- 스택 프레임에 독립적인 전역 변수


> ❓ 왜 사용하지 않을까 ❓</br>
규모에 따라 코드가 커지면 여러 메서드에서 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장되어 있는 값을 파악하기 어렵기 때문.


### 멀티 스레드 / 멀티 프로세스의 이해

- **멀티 스레드 (Multi Thread)** : 스택 영역을 스레드 개수만큼 분할해서 사용
- **멀티 프로세스 (Multi Process)** : 다수의 데이터 저장 영역 / 다수의 T 메모리를 갖는 구조

|      |                                               MT                                               |                           MP                            |
|:----:|:----------------------------------------------------------------------------------------------:|:-------------------------------------------------------:|
|  장점  | 하나의 T 메모리 안에 스택 영역을 분할한 것이라 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 **스태틱 영역과 힙 영역은 공유**해서 사용하는 구조 | 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 **메모리 안전 구조**  |
|  단점  |                               만약 전역 변수를 사용할 경우 **스레드의 안전성**이 깨짐.                               |                       메모리 사용량이 큼.                       |

---
### 🌱 느낀 점 & 알게된 점
    기본적으로 스택, 스태틱 공간에서 어떤 식으로 저장이 되고 소멸이 되는 지 책에서 그림으로 설명이 되어 있어서 이해하기 편했다.
    그리고 마지막에서 다룬 예제를 제대로 이해하지 못해서 함께 이야기 해봤으면 좋겠다! 
