# 02 자바와 절차적 / 구조적 프로그래밍

### 1️⃣ 객체 지향 프로그램의 메모리 사용 방식
객체 지향 프로그램에서는 **데이터 저장 영역(T 메모리 구조)** 을 아래와 같이 3개의 영역으로 분할하여 사용한다
<table>
<thead>
  <tr>
    <td rowspan="2">코드 실행 영역</td>
    <td colspan="2">static(클레스의 놀이터) 영역</td>
  </tr>
  <tr>
    <td>stack(메서드의 놀이터) 영역</td>
    <td>heap(객체의 놀이터) 영역</td>
  </tr>
</thead>
</table>

```
  💡 참고
     * JDK(Java Development Kit) : 자바 개발 도구
     * JRE(Java Runtime Environment) : 자바 실행 환경
     * JVM(Java Virtual Machine) : 자바 가상 기계
``` 
### 2️⃣ 자바에 존재하는 절차적/구조적 프로그래밍의 유산
- **절차적 프로그래밍 : goto를 쓰지 말라**
  - goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해짐
  - goto문 : 제어 흐름을 이리저리 이동시키는 용도
- **구조적 프로그래밍 : 함수를 쓰라**
  - 중복 코드를 한 곳에 모아서 관리 가능
  - 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있음
```
  💡 참고
     공유 사용 시 문제가 발생하기 쉬운 전역변수보다 지역변수 사용 권장
``` 
**⭐ 함수는 클래스나 객체와 아무 관계가 없지만 메서드는 반드시 클래스 정의 안에 존재해야 한다**

### 3️⃣ main() 메서드
```java
public class Start {
  public static void main(String[] args) { // main() 메서드의 스택 프레임 생성
    System.out.println("Hello OOP!!!");
  } // 스택 프레임 소멸
}
``` 
main()메서드가 있는지 확인 → JVM에 전원을 넣어 부팅 → 부팅된 JVM은 목적 파일을 맏아 그 목적 파일을 실행

#### 📌 main() 메서드 실행되기 전 JVM에서 수행하는 전처리 작업
- java.lang 패키지를 T 메모리의 스태틱 영역에 배치
- import 된 패키지를 T 메모리의 스태틱 영역에 배치
- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치

메인 메서드가 실행되려면 메인 메서드를 위한 **스택 프레임**이 필요하다. 이를 스택 영역에 확보해준다.
이후 **메서드의 인자를 저장할 변수공간**을 스택 프레임의 맨 밑에 확보한다.

![1](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/b46502d8-5a26-4f80-9736-89699270fb6a)

간단한 프로그램을 시작하기 위해 JRE는 뒤에서 JVM이라는 가상 머신을 부팅하고 JVM은 메모리 구조를 만들어 각종 패키지 로딩, 메인 메서드 스택 프레임 배치, 변수 공간 배치 등의 일을 처리했다.
메서드의 끝을 나타내는 닫는 중괄호를 만나면 생성한 스택 프레임이 사라진다.
프로그램의 시작점인 메인 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라지게 된다.

### 4️⃣ 변수와 메모리
```java
public class Start2 {
	public static void main(String[] args) {
		int i; // 메모리에 4바이트 크기의 정수 저장 공간을 main() 메서드 스택 프레임 안에 마련
		i = 10;

		double d = 20.0; // 변수를 선언하는 명령문과 변수에 값을 할당하는 명령문
	} // main() 메서드 스택 프레임이 스택 영역에서 사라짐 → 프로그램 종료
}
```
![11](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/d96a0acf-61b7-4b98-a5ee-640e10cf520f)

i를 선언하게 되면 JVM이 i 변수를 위한 스택 공간을 확보한다. 이 후 값을 할당하면 변수 공간에 값을 할당하게 된다.
d는 선언과 동시에 값을 할당했다. 똑같이 스택 공간을 먼저 확보하고 값을 할당하게 된다.

### 5️⃣ 블록 구문과 메모리
```java
public class Start3 {
	public static void main(String[] args) {
		int i = 10;
		int k = 20;

		if(i == 10) {
      int m = k + 5; // if 블록 스택 프레임을 수행하는 중에 if 블록 스택 프레임 외부에 존재하는 변수 k는 접근 가능함(메모리 상에 변수 k가 존재하니 당연히 접근 가능) → 외부 스택 프레임에서 내부 스택 프레임 변수에 접근하는 것은 불가능하나 그 역은 가능⭐
      k = m;
    } else { // if 블록 중 참일 때의 블록을 종료하는 닫는 중괄호를 만나면 if 블록 스택 프레임은 스택 영역에서 사라지며 if 블록 스택 프레임 안에 상주하던 변수 m의 저장 공간도 사라짐
      int p = k + 10; // else 문 블록은 스택 메모리에 등장조차 못하게 됨 
      k = p;
    }

    // k = m + p; → T 메모리를 보면 m 변수와 p 변수는 존재하지 않아 실행하면 오류 발생
	} // main() 메서드 스택 프레임 소멸 → T 메모리 소멸, JVM 기동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납
}
```
![111](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/190e42f2-6f28-474f-bbb9-6488abdc018b)

if 블록 사용시에도 새로운 스택 프레임이 생성되며 if 블록 밖에 있는 메인 메서드 내 변수에는 접근이 가능하다.

### 6️⃣ 지역 변수와 메모리
변수는 T 메모리 세 군데 모두 존재하며 각 영역마다 다른 목적을 가지고 있다.
- **지역변수 :**
스택 프레임 안에서 일생을 보내므로 스택 프레임이 사라지면 함께 사라짐
- **클래스 멤버 변수 :**
스태틱 영역에서 일생을 보내며 스태틱 영역에 한 번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킴
- **객체 멤버 변수 :**
힙에서 일생을 보내며 객체와 함께 가비지 컬렉터라고 하는 힙 메모리 회수기에 의해 일생을 마치게 됨

### 7️⃣ 메서드 호출과 메모리
메서드 호출 과정에서 T 메모리의 변화
```java
public class Start4 {
	public static void main(String[] args) {
		int k = 5;
		int m;

		m = square(k); // square 메소드 호출
	} // main() 메서드 스택 프레임을 메모리에서 사라지게 함 → 모든 프로그램 종료

	private static int square(int k) {
		int result;
		
		k = 25;

		result = k; // result 변수에 25라는 값이 저장

		return result; // 호출한 쪽에서 돌려줄 값을 가져야 할 반환값 변수에 result 변수에 담긴 값이 복사됨
	} // square() 메서드 스택 프레임은 스택에서 사라짐(반환값이 있으니 그 값을 돌려주면서 스택에서 사라짐)
}
```
![1111](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/0b7391bf-22d4-4d6c-a886-1fb93d72e583)
- sqaure메서드는 새로운 스택 프레임을 만든다.
- **Call By Value(값에 의한 호출) :**
  square메서드의 k와 메인 메서드의 k는 이름은 같지만 완전히 별도의 변수 공간을 가지므로 서로에게 영향을 주지 않는다.
- square의 result 값은 메서드 종료 시 사라지므로 "반환 값"에 복사하고 함수를 종료해야만 메인에서 값을 받을 수 있다.
- **메서드의 블랙박스화 :**
 입력값과 반환값에 의해서만 메서드 사이에 값이 전달될 뿐 서로 내부의 지역변수를 볼 수 없다.

#### 📌 메서드 간 변수 참조를 금지한 이유
1. 메서드는 자신만의 고유한 공간이므로 침범하면 안된다.
2. 서로의 변수를 참조하려면 위치(주소)를 알아야 하는데 그럴러면 포인터가 필요하다. (포인터 없는게 자바의 장점)
3. 포인터가 없어서 메서드간 변수 참조가 불가능하다.

자바는 메서드를 호출하면 인자를 저장한 값을 복사해서 전달하는 `Call by value`방식을 사용하고 있다.

객체를 넘기는 것도 객체의 주소값을 복사해서 넘기는 것이다. → 자바는 사실상 `Call by reference`가 없다.

### 8️⃣ 전역 변수와 메모리
```java
public class Start5 {
	static int share; // T 메모리의 스태틱 영역에 변수 공간 할당

	public static void main(String[] args) { // T 메모리에 main() 메서드 스택 프레임 생성
		share = 55;

		int k = fun(5, 7);

		System.out.println(share);
	}

	private static int fun(int m, int p) {
		share = m + p;

		return m - p;
	} // fun() 메서드 스택 프레임이 사라지면서 호출된 곳으로 반환값을 돌려줌
}
```
![11111](https://github.com/GDSC-SKHU/OOP-Study/assets/80957486/9016584b-9756-4b3b-bfa9-7948aee0f4bb)

전역 변수는 스태틱 영역에 할당되는 것을 확인할 수 있다.
메인 메서드와 fun()메서드 두 곳 모두에서 변수에 접근있다.

#### 📌 지역변수와 전역변수
- 지역변수 : 
  - 스택 프레임에 종속적임
- 전역변수 : 
  - 스택 프레임에 독립적임
  - 코드 어느 곳에서나 접근할 수 있음
  - 여러 메서드들이 공유해서 사용한다고 해서 **공유 변수**라고도 함

**⭐ 전역 변수는 프로젝트 규모가 커지면 값의 변화를 추적하기가 어려우니 무조건 피하자!**

### 9️⃣ 멀티 스레드 / 멀티 프로세스의 이해
#### 멀티 스레드
<table>
<tbody>
<tr>
    <td colspan="3">스태틱 영역</td>
  </tr>
  <tr>
    <td colspan="2">스택 영역 - 메서드들의 놀이터</td>
    <td rowspan="2">힙 영역</td>
  </tr>
  <tr>
    <td>스레드</td>
    <td>스레드</td>
  </tr>
</tbody>
</table>

- 스택 영역을 스레드 개수만큼 분할해서 사용
- 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조
- 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조
- 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조
- 쓰기 가능한 전역변수 사용은 스레드 안전성이 깨지고 이를 보완하기 위한 lock은 멀티 스레드의 장점을 버린 것과 같다

#### 멀티 프로세스
<table>
<tbody>
  <tr>
    <td colspan="2">스태틱 영역</td>
  </tr>
  <tr>
    <td>스택 영역</td>
    <td>힙 영역</td>
  </tr>
</tbody>
</table>

<table>
<tbody>
  <tr>
    <td colspan="2">스태틱 영역</td>
  </tr>
  <tr>
    <td>스택 영역</td>
    <td>힙 영역</td>
  </tr>
</tbody>
</table>

<table>
<tbody>
  <tr>
    <td colspan="2">스태틱 영역</td>
  </tr>
  <tr>
    <td>스택 영역</td>
    <td>힙 영역</td>
  </tr>
</tbody>
</table>

- 자료 저장 영역에 다수의 T 메모리를 사용
- 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없음
- 메모리 사용량 큼
