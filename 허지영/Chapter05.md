### 05. 객체 지향 설계 5원칙 - SOLID


Q. 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙이 존재할까? 
A. SOLID 법칙이 있다.
```
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
2. OCP(Open Closed Principle) : 개방 폐쇄 원칙
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
``` 
응집도는 높이고 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다.
<br>좋은 소프트웨어 설계를 위해서는 <b>결합도는 낮추고 응집도는 높이는 것</b>이 바람직하다.
<br>결합도는 클래스 간의 상호 의존 정도로서 결합도가 낮으면 클래스 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이해진다.
<br>응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.

```
결합도 수준
데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도
``` 

```
응집도 수준
기능 응집도, 순차 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도
``` 

SOLID는 4대 특성을 발판으로 하고 있으며, 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이기도 하다. 

## 1. SRP - 단일 책임 원칙
단 하나의 책임만 가져야 한다는 원칙을 말한다. 여기서 '책임' 이라는 의미는 하나의 '기능 담당'으로 보면 된다.
<br>즉, <b>하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되어야 있어야 한다는 의미</b>이다.
<br>단일 책임 원칙은 잘못된 경우를 살펴보는 것이 이해하는데 좋다. 
<br>다음 예시는 속성이 단일 책임 원칙을 지키지 못 하는 경우이다. 
<br>객체 지향 세계는 반드시 군대를 가고, 여자는 절대로 군대를 가지 않는다. 그런데 사람 클래스 속성이 있다면?

```java
class 사람 {
    String 군번;
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

}
```
사람형 참조 변수 줄리엣이 가진 군번 속성에 값을 할당하거나 읽어오는 코드를 제제할 방법이 없다.
<br>그렇다면 사람 클래스를 남자 클래스와 여자 클래스로 분할하고 남자 클래스에만 군번 속성을 갖게 리팩토링 해보자.
<br>바로 단일 책임 원칙을 적용하는 것이다. 
<br>이때 남자 클래스와 여자 클래스에 공통점이 없다면 사람 클래스는 제거하면 되고, 공통점이 많다면 사람 클래스를 상위 클래스로 해서 공통점을 사람 클래스에 두고 남자 클래스와 여자 클래스는 사람 클래스를 상속하고 차이점만 구현하면 된다.
<br><br>
하나의 속성이 여러 의미를 갖는 경우도 단일 책임 원칙을 지키지 못 하는 경우이다.
<br>다음 예시는 메소드가 단일 책임 원칙을 지키지 못 하는 경우이다.
```java
class 강아지 {
    final static Boolean 수컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;
    
    void 소변보다(){
      if(this.성별  == 수컷) [
        // 한 쪽 다리를 들고 소변을 본다....
      } else {
        // 뒷 다리 두 개를 굽혀 앉은 자세로 소변을 본다...............
      }
    }
}
```
강아지가 수컷이냐 암컷이냐에 따라 메소드에서 분기 처리가 진행되는 것을 볼 수 있다. 
<br>강아지 클래스의 소변보다() 메소드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임 원칙을 위배하는 것이다.
<br>이런 경우 다음과 같이 리팩토링 할 수 있다. 
```java
abstract class 강아지 {
    abstract void 소변보다()
}
    
class 수컷강아지 extednds 강아지 {
  void 소변보다() {
    // 한 쪽 다리를 들고 소변을 본다....
  }
}

class 암컷강아지 extends 강아지 {
  void 소변보다() {
    // 뒷 다리 두 개를 굽혀 앉은 자세로 소변을 본다...............
  }
}
```
단일 책임 원칙과 관계가 깊은 객체 지향 4대 특성은 <b>추상화</b>이다. 
<br>애플리케이션의 경계를 정하고 추상화를 통해 클래스를 선별하고 속성과 메소드를 설계할 때 반드시 단일 책임 원칙을 고려해야 한다.
<br>또한 리팩토링을 통해 코드를 개선할 때도 단일 책임 원칙을 적용할 곳이 있는지 꼼꼼히 살펴봐야 한다.

## 2. OCP - 개방 폐쇄 원칙
<b>자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다는 원칙</b>이다.
<br>예시로, 편의점에서는 일일 직원이 교대한다. 주말에는 다른 아르바이트 직원이 근무하기도 한다.
<br>하지만 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는 데는 영향이 없다.
<br>편의점 직원 중 한 명은 구매 담당자일 수도 있다. 또다른 직원은 보안 담당자일 수도 있다.
<br>편의점 직원이 근본적으로 판매라고 하는 행위, 즉 손님과의 인터페이스가 바뀌지 않는 한 손님의 구매라는 행위는 직원이 세부적으로 구매 담당자든, 보안 담당자든 심지어 남자에서 여자로, 학생에서 노인으로 교대된다고 해도 전혀 영향받지 않을 것이다.
<br>직원 교대라고 하는 주변의 변화에는 손님의 구매 행위는 영향을 받지 않는 것이고, 직원은 교대라고 하는 확장 행위에는 열려 있는 것이다.
<br>또한 교대 이외에도 구매 담당자의 행위를 추가하거나, 보안 담당자의 행위를 추가하는 확장에 대해 직원은 열려있다.
<br><br>
개방 페쇄 원칙을 따르지 않는다고 해서 객체 지향 프로그램을 구현하는 것이 불가능한 것은 아니지만 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그램의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
<br>따라서 객체 지향 프로그래밍에서 개방 페쇄 원칙은 반드시 지켜야 할 원칙이다.

## 3. LSP - 리스코프 치환 원칙
<b>서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙</b>이다.
<br>객체 지향의 상속은 다음 조건을 만족해야 한다. 
```
하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.
구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
``` 
위 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다. 
<br>하지만 위 문장대로 구현되지 않은 코드가 존재할 수 있는데 바로 상속이 조직도나 계층도 형태로 구축된 경우다.
<br>예시로 아버지를 상위 클래스(기반 타입)로 하는 딸이라는 하위 클래스(서브 타입)가 있다고 하자. 
<br>전형적인 계층도 형태이며, 객체 지향의 상속을 잘못 적용한 예이다.
```
아버지 춘향이 = new 딸();
``` 
춘향이는 아버지형 객체 참조 변수이기에 아버지 객체가 가진 행위(메소드)를 할 수 있어야 하는데 춘향이에게 아버지의 어떤 역할을 시킬 수 있을까?
<br>하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 하지만, 위의 예시는 문제가 발생하므로 리스코프 치환 원칙을 위반한다.

## 4. ISP - 인터페이스 분리 원칙
<b>클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다는 원칙</b>이다.
<br>단일 책임 원칙과 인터페이스 분할 원칙은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
<br>프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택하여 설계할 수 있다.
<br>하지만 특별한 경우가 아니라면 <b>단일 책임 원칙을 적용하는 것이 더 좋은 해결책</b>이다.

## 5. DIP - 의존 역전 원칙
객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙이다.
<br>즉, <b>자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것</b>이다.
<br>상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.

## 6. 정리 - 객체 지향 세계와 SOLID
SOLID를 이야기할 때 빼놓을 수 없는 <b>SoC는 관심사의 분리(Separation Of Concerns)</b>의 머리글자이다.
<br><b>관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것</b>이다.
<br>하나의 속성, 하나의 메소드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다는 것이 SoC이다.
<br>SoC를 적용하면 자연스럽게 SOLID를 극한까지 적용할 수 있다.
<br>SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아지는 경향이 있지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 이해하기 쉽고, 개발하기 쉬우며, 유지보수와 관리하기 쉬운 소스가 만들어진다.
