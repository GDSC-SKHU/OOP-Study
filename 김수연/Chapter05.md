# 5장

## 목차
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Principle): 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존 역전 원칙

# 1. SRP - 단일 책임 원칙
>"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다" - 로버트 C. 마틴

- 클래스와 메서드는 하나의 역할만 하도록 해야한다.
- 다시 말해, 클래스의 역할과 책임을 너무 많이 주면 안된다.

## 속성의 SRP 위배
  - 문제가 되는 코드
  ```java
public class 사람 {
	String 군번;

	public static void main(String[] args) {
		사람 로미오 = new 사람();
		사람 줄리엣 = new 사람();

		줄리엣.군번 = "11-730411994";
	}
}
  ```
❌ 줄리엣은 여자이므로 '군번'을 가질 수 없다. 

하지만 줄리엣은 군번 속성에 값을 할당하거나 읽어올 수 있다.

** 가질 수 없는 속성 개선 **

이를 개선하기 위해선 **남자 클래스만** 군번을 갖게 한다.
-  여자와 남자의 공통적만 모아 사람 클래스를 상위 클래스로 만들 수도 있고 둘의 공통점이 없다면 남자 클래스와 여자 클래스로 나눠서 구현할 수 있다. 

** 하나의 속성이 여러 속성을 가지는 경우 **

- 데이터베이스 테이블에 존재하는 하나의 필드가 여러 속성을 가르키게 되면 정규화를 통해 단일 책임 원칙을 유지하도록 해야한다.

 ## 메서드가 SRP 위배
   - 문제가 되는 코드

```java
public class 강아지 {
	final static Boolean 숫컷 = true;
	final static Boolean 암컷 = false;
	Boolean 성별;

	void 소변보다() {
		if (this.성별 == 숫컷) {
			// 한쪽 다리를 들고 소변을 본다.
		} else {
			// 뒤다리 두 개로 앉은 자세로 소변을 본다.
		}
	}
}
  ```
> 강아지가 "수컷"인지 "암컷"인지에 따라 메서드에서 분기 처리가 진행되고 있다.
- 이는 강아지 클래스에서 "소변보다"의 암컷과 수컷 강아지의 행위를 **모두** 구현하려고 했기 때문에 "단일 책임 원칙"을 위배하게 됨.

- 개선 코드

(추상 클래스를 만들어 각각의 하위 클래스에서 메서드를 상속 받아 사용)
```java
public abstract class 강아지 {
	abstract void 소변보다();
}

public class 숫컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

public class 암컷강아지 extends 강아지 {
	void 소변보다() {
		// 뒤다리 두 개로 앉은 자세로 소변을 본다.
	}
}
  ```
 > **📌 하나의 클래스에 하나의 기능을 가지고 있다.**

  -> 암컷과 수컷 강아지의 서로 다른 행위의 구현을 하위 클래스에 맡겼기 때문에 "단일 책임 원칙"을 지킬 수 있었다.

 **모델링을 담당하는 "추상화"는 "단일 책임 원칙"과 가장 관계가 깊다.
 
-> "애플리케이션 경계(context)"를 정하고 추상화를 통해 클래스의 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하자!!

 # 2. OCP - 개방 폐쇄 원칙
 >"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

-> "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."

 - 부모클래스를 가리키는 포인터에 해당 클래스를 상속하는 자식 클래스를 할당한다면 모든기능이 정상적으로 작동해야한다.
- 다시 말해, 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용한다해도 문제가 없어야 한다.

<문제 코드>

운전자(자신)가 "소나타"를 운전하든 "마티즈"(주변)를 운전하든 행동에 변화가 오면 안된다.

-> 주변의 변화에 자신이 변화해야 하는 경우 (문제)

현실 세계 였다면 자신이 변화하면 되는 문제지만 객체지향 세계는 다른 해결책을 사용한다.


<img src="./image/i25.png " width=450 height=300 />

상위 클래스 or 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체지향세계의 운전자는 운전 습관에 영향을 받지 않게 된다. 

📌 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에 개방돼 있는 것 이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것 이다
- 운전자의 입장에선 주변의 변화에 영향을 받지 않게 된다. (마티즈 - 소나타 든 신경안씀)
- 자동차의 입장에선 자신의 확장에 개방되 있는 것이다. (마티즈 - 소나타로 확장) 

❌ OCP를 위반한 코드
```java
public class NOT_OCP운전자 {
	public static void main(String[] args) {

		소나타 운전자 = new 소나타();
		  운전자.drive();
		
		그랜저 운전자2 = new 그랜저();
		  운전자2.drive();
		
		BMW 운전자3 = new BMW();
		  운전자3.drive();
	}

}

class 소나타{	
	void drive() {
		System.out.println("소나타 운전");
	}
}

class 그랜저{	
	void drive() {
		System.out.println("그랜저를 운전");
	}
}

class BMW{	
	void drive() {
		System.out.println("BMW를 운전");
	}
}

```
>운전자 객체가 생성될 때부터 각 차량 클래스에 과하게 의존하고 있음

⭕️ OCP를 적용한 코드

```java
ublic class OCP운전자 {

	public static void main(String[] args) {
		
		자동차[] 운전자 = new 자동차[3];
		
		운전자[0] = new 소나타();
		운전자[1] = new 그랜저();
		운전자[2] = new BMW();
		
		for(int i=0; i<운전자.length; i++) {
			운전자[i].drive();
		}

	}

}

class 자동차{
	String myCar="자동차";
	void drive() {
		System.out.printf("%s 를 운전",  myCar);
	}
}

class 소나타 extends 자동차{
	public 소나타() {
		myCar = "소나타";
	}	
}

class 그랜저 extends 자동차{	
	public 그랜저() {
		myCar = "그랜저";
	}
}

class BMW extends 자동차{	
	public BMW() {
		myCar = "BMW";
	}
}

```
> 여기서 확장하고 싶다면?
```java
 Class 현대 extends 자동차 {
        public 현대() {
            myCar = "현대";
        }
    }

//메인 메서드 추가 
public static void main(String[] args) {
    
        운전자[3] = new 현대(); //추가
		운전자[3].drive();

	}
```

>**새로운 자동차를 하나 더 추가하는 상황에서도 기존 drive() 메서드나 자동차 클래스의 코드가 전혀 변경되지 않았음!**


# 3. LSP - 리스코프 치환 원칙

> "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다" - 로버트 C. 마틴

리스코프 치환 원칙을 잘 지키고 있는 클래스
- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스  - 구현 분류는 인터페이스할 수 있어야 한다.
- 리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체할 수 있어야한다고 권고한다.

**📌 올바르게 성립하는 상속 관계를 구현하기!**

❌ 잘못된 상속 예시 ❌

아버지 - 딸 (기반 타입 - 서브 타입)은 계층도 형태의 잘못된 상속이라고 볼 수 있다.

>그렇다면 무엇이 문제일까? 한번 리스코프 치환 법칙을 적용해보자.

아버지 춘향이 = new 딸() -> 불가능!!!!
딸이 태어나 아버지의 역할을 하는 것은 말이 안된다.

* 춘향이는 아버지형 객체 참조 변수를 가지므로 아버지 객체가 가진 행위를 할 수 있어야 한다. 하지만 할 수 없음 !

⭕️ 올바른 예시 ⭕️

동물 뽀로로 = new 펭귄() 
펭귄 한 마리가 새롭게 태어나 동물의 행위를 한다. -> 이상한 점 없음
- 리스코프 치환 원칙을 만족한다.

**결론**

-> "하위 클래스 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다"

<img src="./image/i26.png " width=550 height=300 />

# 4. ISP - 인터페이스 분리 원칙

>클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴

- 자신이 필요로 하는 인터페이스에만 의존하며, 필요하지 않은 기능에 대해서는 관여하지 않는다. 

## 남자클래스
<img src="./image/i27.png " width=450 height=300 />

-> 너무 많은 책임과 역할을 가짐 


## 인터페이스 분할 원칙
<img src="./image/i28.png " width=450 height=300 />

- 남자 클래스를 제한시켜
직장상사와 있을 땐 "출근하기(), 아부하기()" 행위만 하도록 제한하고
어머니와 있을 땐 "효도하기(), 안마하기()" 행위만 하도록 제한시키는 방법

> 인터페이스 분할 원칙은 인터페이스 최소주의 원칙을 가진다.
- 최소주의란 인터페이스를 통해 외부에 메서드 제공시 최소한의 메서드만 제공해야한다.
- 예를 들어, 사원 인터페이스에 기념일챙기기() 메서드를 제공하면 안되는 것과 같은 이유이다.**(사원의 책임에 부합하지 않는다.)**

## 정리 
1. 상위 클래스는 풍성할수록 좋고 "인터페이스"는 작을수록 좋다.
2. 풍성한 상위 클래스에서는 하위 클래스에서 공통으로 가질 속성과 메서드를 상속한다.

# 5. DIP - 의존 역전 원칙

> - "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
> - "추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
> - "자주 변경되는 구체(Concreate) 클래스에 의존하지 마라" - 로버트 C. 마틴

-> "자신보다 변하기 쉬운 것에 의존하지 마라."

<img src="./image/i29.png " width=450 height=300 />
자동차와 스노우타이어 사이에는 의존 관계가 존재한다.

자동차가 스노우타이어에 의존하는 관계이다.

> 자동차는 10년이상도 탈 수 있지만 스노우타이어는 계절이 바뀌면 일반 타이어로 바꿔줘야 한다.

-> 즉, 스노우타이어가 자동차보다 자주 변경된다.

개선 방법
<img src="./image/i30.png " width=450 height=300 />
>자동차가 구체적인 타이어들이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어 종류를 변경해도 자동차는 영향을 받지 않음
- 자동차가 "스노우타이어"가 아닌 추상화된 타이어 인터페이스에 의존하게 해보자.

- 인터페이스의 구현체가 변경(스노우 -> 일반)되도 자동차는 그 영향을 받지 않는다.
 
 